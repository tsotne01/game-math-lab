---
import ModuleLayout from '../../../layouts/ModuleLayout.astro';
import CameraController, { FrustumVisualizer, CameraInterpolation, DollyZoom, SplitScreenComparison, CameraMatrixDisplay } from '../../../components/modules/CameraController';
import Quiz from '../../../components/lessons/Quiz';
import MarkComplete from '../../../components/ui/MarkComplete';
import CodeBlock from '../../../components/ui/CodeBlock';
import type { QuizQuestion } from '../../../components/lessons/Quiz';

// Quiz questions for Module 17
const quizQuestions: QuizQuestion[] = [
  {
    type: 'multiple-choice',
    question: 'What three properties define a camera\'s orientation in 3D space?',
    options: [
      'Width, height, depth',
      'Position, target (lookAt), up vector',
      'FOV, near plane, far plane',
      'Yaw, pitch, roll'
    ],
    correctIndex: 1,
    explanation: 'A camera needs a position (where it is), a target (what it\'s looking at), and an up vector (which way is "up"). These three define the view matrix through the lookAt function.'
  },
  {
    type: 'multiple-choice',
    question: 'When should you use an orthographic camera instead of perspective?',
    options: [
      'For realistic 3D games',
      'For first-person shooters',
      'For isometric games, 2D games, or CAD applications',
      'When performance is critical'
    ],
    correctIndex: 2,
    explanation: 'Orthographic projection maintains object sizes regardless of distance, making it ideal for isometric games (like classic RPGs), 2D games rendered in 3D, and CAD/technical applications where accurate measurements matter.'
  },
  {
    type: 'multiple-choice',
    question: 'What is the "frustum" in camera terminology?',
    options: [
      'The camera\'s resolution',
      'The pyramid-shaped visible volume defined by near/far planes and FOV',
      'The camera\'s rotation speed',
      'A type of lens distortion'
    ],
    correctIndex: 1,
    explanation: 'The view frustum is the truncated pyramid that represents everything the camera can see. Objects outside this volume are culled (not rendered). It\'s defined by the field of view, aspect ratio, and near/far clipping planes.'
  },
  {
    type: 'multiple-choice',
    question: 'In a follow/third-person camera, what does "smoothing" or "damping" control?',
    options: [
      'The camera\'s resolution',
      'How quickly the camera catches up to the target',
      'The field of view',
      'The near clipping plane'
    ],
    correctIndex: 1,
    explanation: 'Smoothing/damping controls how quickly the camera interpolates to its target position. Low values make the camera feel floaty and cinematic; high values make it snap quickly to the target.'
  },
  {
    type: 'multiple-choice',
    question: 'What creates the "dolly zoom" (Vertigo) effect?',
    options: [
      'Rotating the camera quickly',
      'Moving the camera while changing FOV to keep subject size constant',
      'Using an orthographic camera',
      'Adding motion blur'
    ],
    correctIndex: 1,
    explanation: 'The dolly zoom moves the camera toward/away from the subject while simultaneously changing the FOV to maintain the subject\'s apparent size. This causes the background to dramatically compress or expand, creating an unsettling effect.'
  },
  {
    type: 'code-completion',
    question: 'Complete the lookAt camera direction calculation:',
    codeTemplate: `function lookAt(eye, target, up) {
  // Forward direction (from eye to target)
  const forward = normalize(subtract(___, ___));
  // Right direction
  const right = normalize(cross(up, forward));
  // True up direction
  const trueUp = cross(forward, right);
  return { forward, right, trueUp };
}`,
    answers: ['target, eye', 'target,eye'],
    explanation: 'The forward direction points from the camera position (eye) toward what it\'s looking at (target). We calculate it as normalize(target - eye), giving us a unit vector in the viewing direction.'
  },
  {
    type: 'multiple-choice',
    question: 'What is the advantage of using SLERP over LERP for camera rotation interpolation?',
    options: [
      'SLERP is faster to compute',
      'SLERP maintains constant angular velocity (no speed-up/slow-down)',
      'SLERP uses less memory',
      'SLERP works with Euler angles'
    ],
    correctIndex: 1,
    explanation: 'Spherical Linear Interpolation (SLERP) interpolates along the surface of a sphere, maintaining constant angular velocity. Regular LERP can cause the rotation to speed up in the middle of the transition, making it look unnatural.'
  },
  {
    type: 'multiple-choice',
    question: 'In cinematic camera systems, what does a "keyframe" represent?',
    options: [
      'A keyboard shortcut',
      'A specific camera position/orientation at a point in time',
      'The frame rate setting',
      'A type of camera shake'
    ],
    correctIndex: 1,
    explanation: 'Keyframes are defined camera states (position, rotation, FOV, etc.) at specific times. The camera system interpolates between keyframes to create smooth camera movements for cutscenes and cinematics.'
  }
];

// Code snippets
const codeBasicCamera = `// Camera basics: Position, Target, Up Vector
const camera = {
    position: { x: 0, y: 5, z: 10 },  // Where the camera is
    target: { x: 0, y: 0, z: 0 },     // What it's looking at
    up: { x: 0, y: 1, z: 0 }          // Which way is "up"
};

// lookAt function - creates view matrix from these three vectors
function lookAt(eye, target, up) {
    // Calculate camera axes
    const zAxis = normalize(subtract(eye, target));  // Forward (looking INTO camera)
    const xAxis = normalize(cross(up, zAxis));       // Right
    const yAxis = cross(zAxis, xAxis);               // True up
    
    // Build 4x4 view matrix
    return [
        [xAxis.x, xAxis.y, xAxis.z, -dot(xAxis, eye)],
        [yAxis.x, yAxis.y, yAxis.z, -dot(yAxis, eye)],
        [zAxis.x, zAxis.y, zAxis.z, -dot(zAxis, eye)],
        [0,       0,       0,       1]
    ];
}`;

const codePerspectiveOrtho = `// Perspective projection - objects shrink with distance
function perspectiveMatrix(fov, aspect, near, far) {
    const f = 1 / Math.tan(fov / 2);  // Focal length
    const rangeInv = 1 / (near - far);
    
    return [
        [f/aspect, 0, 0, 0],
        [0, f, 0, 0],
        [0, 0, (near+far)*rangeInv, 2*near*far*rangeInv],
        [0, 0, -1, 0]  // The -1 enables perspective divide
    ];
}

// Orthographic projection - parallel rays, no size change
function orthographicMatrix(left, right, bottom, top, near, far) {
    return [
        [2/(right-left), 0, 0, -(right+left)/(right-left)],
        [0, 2/(top-bottom), 0, -(top+bottom)/(top-bottom)],
        [0, 0, -2/(far-near), -(far+near)/(far-near)],
        [0, 0, 0, 1]
    ];
}`;

const codeOrbitCamera = `// Orbit camera - rotate around a target point
class OrbitCamera {
    constructor(target, distance, minPolar = 0.1, maxPolar = Math.PI - 0.1) {
        this.target = target;
        this.distance = distance;
        this.theta = 0;      // Horizontal angle (azimuth)
        this.phi = Math.PI/4; // Vertical angle (polar)
        this.minPolar = minPolar;
        this.maxPolar = maxPolar;
    }
    
    rotate(deltaTheta, deltaPhi) {
        this.theta += deltaTheta;
        this.phi = Math.max(this.minPolar, 
                   Math.min(this.maxPolar, this.phi + deltaPhi));
    }
    
    zoom(delta) {
        this.distance = Math.max(1, this.distance + delta);
    }
    
    getPosition() {
        // Convert spherical to Cartesian coordinates
        return {
            x: this.target.x + this.distance * Math.sin(this.phi) * Math.sin(this.theta),
            y: this.target.y + this.distance * Math.cos(this.phi),
            z: this.target.z + this.distance * Math.sin(this.phi) * Math.cos(this.theta)
        };
    }
}`;

const codeFPSCamera = `// First-person camera with mouse look and WASD movement
class FPSCamera {
    constructor(position) {
        this.position = position;
        this.yaw = 0;    // Horizontal rotation
        this.pitch = 0;  // Vertical rotation (clamped)
        this.sensitivity = 0.002;
        this.speed = 5;
    }
    
    handleMouseMove(deltaX, deltaY) {
        this.yaw -= deltaX * this.sensitivity;
        this.pitch -= deltaY * this.sensitivity;
        // Clamp pitch to avoid flipping
        this.pitch = Math.max(-Math.PI/2 + 0.1, 
                    Math.min(Math.PI/2 - 0.1, this.pitch));
    }
    
    getForward() {
        return {
            x: Math.sin(this.yaw) * Math.cos(this.pitch),
            y: Math.sin(this.pitch),
            z: Math.cos(this.yaw) * Math.cos(this.pitch)
        };
    }
    
    getRight() {
        return {
            x: Math.cos(this.yaw),
            y: 0,
            z: -Math.sin(this.yaw)
        };
    }
    
    move(forward, right, deltaTime) {
        const fwd = this.getForward();
        const rgt = this.getRight();
        const speed = this.speed * deltaTime;
        
        this.position.x += (fwd.x * forward + rgt.x * right) * speed;
        this.position.y += fwd.y * forward * speed;
        this.position.z += (fwd.z * forward + rgt.z * right) * speed;
    }
}`;

const codeFollowCamera = `// Third-person follow camera with smoothing
class FollowCamera {
    constructor(offset, smoothing = 5) {
        this.offset = offset;      // Offset from target (e.g., {x:0, y:3, z:8})
        this.smoothing = smoothing; // Higher = faster catch-up
        this.currentPosition = { x: 0, y: 0, z: 0 };
    }
    
    update(targetPosition, targetRotation, deltaTime) {
        // Calculate desired camera position based on target
        const desiredPosition = {
            x: targetPosition.x + this.offset.x,
            y: targetPosition.y + this.offset.y,
            z: targetPosition.z + this.offset.z
        };
        
        // Smoothly interpolate to desired position
        const t = 1 - Math.exp(-this.smoothing * deltaTime);
        this.currentPosition = {
            x: lerp(this.currentPosition.x, desiredPosition.x, t),
            y: lerp(this.currentPosition.y, desiredPosition.y, t),
            z: lerp(this.currentPosition.z, desiredPosition.z, t)
        };
        
        return this.currentPosition;
    }
}

// Exponential smoothing gives frame-rate independent results!`;

const codeCinematicCamera = `// Cinematic camera with keyframe animation
class CinematicCamera {
    constructor(keyframes) {
        this.keyframes = keyframes; // Array of { position, target, time }
        this.currentTime = 0;
    }
    
    update(deltaTime, playing) {
        if (playing) {
            this.currentTime += deltaTime;
            const maxTime = this.keyframes[this.keyframes.length - 1].time;
            if (this.currentTime > maxTime) this.currentTime = 0; // Loop
        }
        
        // Find surrounding keyframes
        let start = this.keyframes[0];
        let end = this.keyframes[1];
        for (let i = 0; i < this.keyframes.length - 1; i++) {
            if (this.currentTime >= this.keyframes[i].time &&
                this.currentTime <= this.keyframes[i+1].time) {
                start = this.keyframes[i];
                end = this.keyframes[i+1];
                break;
            }
        }
        
        // Interpolate with easing
        const duration = end.time - start.time;
        const t = (this.currentTime - start.time) / duration;
        const eased = easeInOutCubic(t);
        
        return {
            position: lerpVector(start.position, end.position, eased),
            target: lerpVector(start.target, end.target, eased)
        };
    }
}

function easeInOutCubic(t) {
    return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2;
}`;

const codeInterpolation = `// Camera interpolation - smooth transitions between views
function interpolateCamera(camA, camB, t, useQuaternion = false) {
    // Linear interpolation for position
    const position = lerpVector(camA.position, camB.position, t);
    
    if (useQuaternion) {
        // SLERP for rotation (smoother, constant angular velocity)
        const rotation = slerp(camA.quaternion, camB.quaternion, t);
        return { position, rotation };
    } else {
        // Simple target interpolation
        const target = lerpVector(camA.target, camB.target, t);
        return { position, target };
    }
}

// Spherical Linear Interpolation (for rotations)
function slerp(q1, q2, t) {
    let dot = q1.w*q2.w + q1.x*q2.x + q1.y*q2.y + q1.z*q2.z;
    
    // Handle negative dot (take shorter path)
    if (dot < 0) {
        q2 = { w: -q2.w, x: -q2.x, y: -q2.y, z: -q2.z };
        dot = -dot;
    }
    
    // If very close, use linear interpolation
    if (dot > 0.9995) {
        return normalize({
            w: q1.w + t*(q2.w - q1.w),
            x: q1.x + t*(q2.x - q1.x),
            y: q1.y + t*(q2.y - q1.y),
            z: q1.z + t*(q2.z - q1.z)
        });
    }
    
    const theta = Math.acos(dot);
    const sinTheta = Math.sin(theta);
    const wa = Math.sin((1-t) * theta) / sinTheta;
    const wb = Math.sin(t * theta) / sinTheta;
    
    return {
        w: wa*q1.w + wb*q2.w,
        x: wa*q1.x + wb*q2.x,
        y: wa*q1.y + wb*q2.y,
        z: wa*q1.z + wb*q2.z
    };
}`;
---

<ModuleLayout 
  title="Camera Systems"
  moduleNumber="17"
  projectName="Camera Controller"
  prevModule={{ href: '/modules/13-3d-intro/', title: 'Intro to 3D Math' }}
>
  <!-- Intro -->
  <section class="mb-16">
    <div class="bg-gradient-to-r from-[#6c5ce7]/20 to-[#00b894]/20 border border-[#6c5ce7] rounded-xl p-6 mb-8">
      <div class="flex items-center gap-3 mb-3">
        <svg class="w-6 h-6 text-accent" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></svg>
        <span class="text-accent font-bold uppercase tracking-wider text-sm">Module 17</span>
      </div>
      <p class="text-text-secondary">
        The camera is your player's window into the game world. In this module, you'll master different camera 
        systems used in games — from simple orbit cameras to complex cinematic sequences. Understanding cameras 
        is essential for creating immersive experiences!
      </p>
    </div>
  </section>

  <!-- Lesson 1: Camera Basics -->
  <section class="mb-16">
    <h2 class="text-2xl font-bold text-accent mb-4 flex items-center gap-2">
      <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></svg>
      1. Camera Basics
    </h2>
    
    <p class="text-text-secondary mb-4">
      Every 3D camera needs three pieces of information to define its orientation:
    </p>
    
    <ul class="list-none space-y-2 mb-6 text-text-secondary">
      <li class="flex items-start gap-2">
        <svg class="w-5 h-5 text-[#51cf66] flex-shrink-0 mt-0.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="1"/></svg>
        <span><strong class="text-white">Position</strong> — Where the camera is located in 3D space</span>
      </li>
      <li class="flex items-start gap-2">
        <svg class="w-5 h-5 text-[#ff6b6b] flex-shrink-0 mt-0.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>
        <span><strong class="text-white">Target (LookAt)</strong> — The point the camera is looking at</span>
      </li>
      <li class="flex items-start gap-2">
        <svg class="w-5 h-5 text-[#339af0] flex-shrink-0 mt-0.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5"/><path d="m5 12 7-7 7 7"/></svg>
        <span><strong class="text-white">Up Vector</strong> — Which direction is "up" for the camera (usually Y-axis)</span>
      </li>
    </ul>

    <p class="text-text-secondary mb-6">
      The <code class="bg-bg-secondary px-2 py-0.5 rounded">lookAt</code> function uses these three vectors to create 
      a <strong class="text-white">view matrix</strong> that transforms world coordinates into camera space.
    </p>

    <CodeBlock client:load code={codeBasicCamera} language="javascript" />
    
    <h3 class="text-xl font-semibold text-white mt-8 mb-4">Try It: Camera Matrix Visualizer</h3>
    <CameraMatrixDisplay client:visible />
  </section>

  <!-- Lesson 2: Perspective vs Orthographic -->
  <section class="mb-16">
    <h2 class="text-2xl font-bold text-accent mb-4 flex items-center gap-2">
      <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21 21-6-6m6 6v-4.8m0 4.8h-4.8"/><path d="M3 16.2V21m0 0h4.8M3 21l6-6"/><path d="M21 7.8V3m0 0h-4.8M21 3l-6 6"/><path d="M3 7.8V3m0 0h4.8M3 3l6 6"/></svg>
      2. Perspective vs Orthographic
    </h2>
    
    <p class="text-text-secondary mb-4">
      The <strong class="text-white">projection matrix</strong> determines how 3D coordinates are mapped to your 2D screen.
      There are two fundamental types:
    </p>

    <div class="grid md:grid-cols-2 gap-4 mb-6">
      <div class="p-4 bg-[#6c5ce7]/10 border border-[#6c5ce7] rounded-lg">
        <h4 class="font-bold text-[#6c5ce7] mb-2">Perspective Projection</h4>
        <ul class="text-sm text-text-secondary space-y-1">
          <li>• Objects shrink with distance</li>
          <li>• Parallel lines converge</li>
          <li>• Realistic 3D appearance</li>
          <li>• Used in: FPS, racing, action games</li>
        </ul>
      </div>
      <div class="p-4 bg-[#00b894]/10 border border-[#00b894] rounded-lg">
        <h4 class="font-bold text-[#00b894] mb-2">Orthographic Projection</h4>
        <ul class="text-sm text-text-secondary space-y-1">
          <li>• Objects maintain size at any distance</li>
          <li>• Parallel lines stay parallel</li>
          <li>• No depth distortion</li>
          <li>• Used in: isometric games, 2D, CAD</li>
        </ul>
      </div>
    </div>

    <CodeBlock client:load code={codePerspectiveOrtho} language="javascript" />
    
    <h3 class="text-xl font-semibold text-white mt-8 mb-4">Try It: Side-by-Side Comparison</h3>
    <SplitScreenComparison client:visible />
  </section>

  <!-- Lesson 3: Orbit Camera -->
  <section class="mb-16">
    <h2 class="text-2xl font-bold text-accent mb-4 flex items-center gap-2">
      <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20"/><path d="M2 12h20"/></svg>
      3. Orbit Camera
    </h2>
    
    <p class="text-text-secondary mb-4">
      The <strong class="text-white">orbit camera</strong> rotates around a target point at a fixed distance.
      It's perfect for 3D model viewers, strategy games, and any situation where the player needs to
      inspect objects from all angles.
    </p>
    
    <p class="text-text-secondary mb-6">
      The camera position is calculated using <strong class="text-white">spherical coordinates</strong>:
    </p>
    
    <ul class="list-none space-y-2 mb-6 text-text-secondary">
      <li class="flex items-center gap-2">
        <span class="w-4 h-4 rounded bg-[#ffd43b]"></span>
        <strong class="text-white">Theta (θ)</strong> — Horizontal angle (azimuth), 0 to 2π
      </li>
      <li class="flex items-center gap-2">
        <span class="w-4 h-4 rounded bg-[#6c5ce7]"></span>
        <strong class="text-white">Phi (φ)</strong> — Vertical angle (polar), typically clamped to avoid gimbal lock
      </li>
      <li class="flex items-center gap-2">
        <span class="w-4 h-4 rounded bg-[#51cf66]"></span>
        <strong class="text-white">Distance (r)</strong> — How far from the target
      </li>
    </ul>

    <CodeBlock client:load code={codeOrbitCamera} language="javascript" />
  </section>

  <!-- Lesson 4: First-Person Camera -->
  <section class="mb-16">
    <h2 class="text-2xl font-bold text-accent mb-4 flex items-center gap-2">
      <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>
      4. First-Person Camera
    </h2>
    
    <p class="text-text-secondary mb-4">
      The <strong class="text-white">first-person camera</strong> puts players directly in the character's eyes.
      It uses <strong class="text-white">yaw</strong> (horizontal rotation) and <strong class="text-white">pitch</strong> 
      (vertical rotation) to control where the player looks.
    </p>
    
    <div class="bg-bg-secondary p-4 rounded-lg mb-6 border border-border">
      <p class="text-sm text-text-secondary mb-2">Key considerations:</p>
      <ul class="text-sm space-y-1 text-text-secondary">
        <li class="text-accent">• Clamp pitch to prevent camera flipping (typically ±89°)</li>
        <li class="text-accent">• Mouse sensitivity should be adjustable</li>
        <li class="text-accent">• Movement is relative to camera direction (forward = where you're looking)</li>
        <li class="text-accent">• Use pointer lock API for smooth mouse capture</li>
      </ul>
    </div>

    <CodeBlock client:load code={codeFPSCamera} language="javascript" />
  </section>

  <!-- Lesson 5: Third-Person/Follow Camera -->
  <section class="mb-16">
    <h2 class="text-2xl font-bold text-accent mb-4 flex items-center gap-2">
      <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>
      5. Third-Person/Follow Camera
    </h2>
    
    <p class="text-text-secondary mb-4">
      A <strong class="text-white">follow camera</strong> trails behind a target (usually the player character).
      The key to a good follow camera is <strong class="text-white">smoothing</strong> — the camera should
      catch up to the target gradually, not instantly.
    </p>
    
    <p class="text-text-secondary mb-6">
      Common approaches include:
    </p>
    
    <ul class="list-none space-y-2 mb-6 text-text-secondary">
      <li class="flex items-start gap-2">
        <svg class="w-5 h-5 text-accent flex-shrink-0 mt-0.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg>
        <span><strong class="text-white">Linear interpolation (lerp)</strong> — Simple but can feel sluggish</span>
      </li>
      <li class="flex items-start gap-2">
        <svg class="w-5 h-5 text-accent flex-shrink-0 mt-0.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg>
        <span><strong class="text-white">Exponential smoothing</strong> — Frame-rate independent, feels natural</span>
      </li>
      <li class="flex items-start gap-2">
        <svg class="w-5 h-5 text-accent flex-shrink-0 mt-0.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg>
        <span><strong class="text-white">Spring physics</strong> — Adds natural oscillation, used in many AAA games</span>
      </li>
    </ul>

    <CodeBlock client:load code={codeFollowCamera} language="javascript" />
  </section>

  <!-- Lesson 6: Cinematic Camera -->
  <section class="mb-16">
    <h2 class="text-2xl font-bold text-accent mb-4 flex items-center gap-2">
      <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m22 8-6 4 6 4V8Z"/><rect width="14" height="12" x="2" y="6" rx="2" ry="2"/></svg>
      6. Cinematic Camera
    </h2>
    
    <p class="text-text-secondary mb-4">
      Cinematic cameras follow predefined paths or keyframes to create dramatic sequences.
      Common cinematic movements include:
    </p>
    
    <ul class="list-none space-y-2 mb-6 text-text-secondary">
      <li class="flex items-center gap-2">
        <svg class="w-4 h-4 text-accent" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>
        <strong class="text-white">Dolly</strong> — Move camera forward/backward toward subject
      </li>
      <li class="flex items-center gap-2">
        <svg class="w-4 h-4 text-accent" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12h14"/></svg>
        <strong class="text-white">Truck</strong> — Move camera left/right parallel to subject
      </li>
      <li class="flex items-center gap-2">
        <svg class="w-4 h-4 text-accent" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19V5"/><path d="m5 12 7-7 7 7"/></svg>
        <strong class="text-white">Pedestal</strong> — Move camera up/down vertically
      </li>
      <li class="flex items-center gap-2">
        <svg class="w-4 h-4 text-accent" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/></svg>
        <strong class="text-white">Pan/Tilt</strong> — Rotate camera horizontally/vertically
      </li>
    </ul>

    <CodeBlock client:load code={codeCinematicCamera} language="javascript" />
  </section>

  <!-- Lesson 7: Camera Interpolation -->
  <section class="mb-16">
    <h2 class="text-2xl font-bold text-accent mb-4 flex items-center gap-2">
      <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3c-1.2 0-2.4.6-3 1.7A3.6 3.6 0 0 0 4.6 9c-1 .6-1.7 1.8-1.7 3s.7 2.4 1.7 3c-.3 1.2 0 2.5 1 3.4.8.8 2.1 1.2 3.3 1 .6 1 1.8 1.6 3 1.6s2.4-.6 3-1.7c1.2.3 2.5 0 3.4-1 .8-.8 1.2-2 1-3.3 1-.6 1.6-1.8 1.6-3s-.6-2.4-1.7-3c.3-1.2 0-2.5-1-3.4a3.7 3.7 0 0 0-3.3-1c-.6-1-1.8-1.6-3-1.6Z"/><path d="m9 12 2 2 4-4"/></svg>
      7. Camera Interpolation
    </h2>
    
    <p class="text-text-secondary mb-4">
      Smooth transitions between camera positions are essential for cutscenes and gameplay transitions.
      The key is choosing the right <strong class="text-white">interpolation method</strong>:
    </p>
    
    <ul class="list-none space-y-2 mb-6 text-text-secondary">
      <li class="flex items-start gap-2">
        <span class="w-4 h-4 rounded bg-[#ff6b6b] mt-1"></span>
        <span><strong class="text-white">Linear (LERP)</strong> — Constant speed, can feel mechanical</span>
      </li>
      <li class="flex items-start gap-2">
        <span class="w-4 h-4 rounded bg-[#51cf66] mt-1"></span>
        <span><strong class="text-white">Ease In/Out</strong> — Accelerate/decelerate, more natural feeling</span>
      </li>
      <li class="flex items-start gap-2">
        <span class="w-4 h-4 rounded bg-[#339af0] mt-1"></span>
        <span><strong class="text-white">SLERP</strong> — Spherical interpolation for rotations, constant angular velocity</span>
      </li>
    </ul>

    <CodeBlock client:load code={codeInterpolation} language="javascript" />
    
    <h3 class="text-xl font-semibold text-white mt-8 mb-4">Try It: Camera Interpolation Demo</h3>
    <CameraInterpolation client:visible />
  </section>

  <!-- Project: Camera Controller -->
  <section class="mb-16">
    <h2 class="text-2xl font-bold text-accent mb-4 flex items-center gap-2">
      <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg>
      Project: Camera Controller
    </h2>
    
    <p class="text-text-secondary mb-6">
      Put everything together! This interactive demo lets you switch between different camera types
      and adjust their parameters in real-time.
    </p>
    
    <ul class="list-none space-y-2 mb-8 text-text-secondary">
      <li class="flex items-center gap-2">
        <svg class="w-4 h-4 text-[#00b894]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg>
        Orbit camera with damping and auto-rotate
      </li>
      <li class="flex items-center gap-2">
        <svg class="w-4 h-4 text-[#00b894]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg>
        First-person camera with WASD and mouse look
      </li>
      <li class="flex items-center gap-2">
        <svg class="w-4 h-4 text-[#00b894]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg>
        Follow camera with adjustable smoothing
      </li>
      <li class="flex items-center gap-2">
        <svg class="w-4 h-4 text-[#00b894]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg>
        Cinematic camera with keyframe playback
      </li>
    </ul>

    <CameraController client:visible />
  </section>

  <!-- Interactive Demos -->
  <section class="mb-16">
    <h2 class="text-2xl font-bold text-accent mb-4 flex items-center gap-2">
      <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>
      Interactive Demos
    </h2>
    
    <h3 class="text-xl font-semibold text-white mt-8 mb-4">Frustum Visualizer</h3>
    <p class="text-text-secondary mb-4">
      See exactly what the camera can see by adjusting FOV and near/far clipping planes.
      Objects outside the frustum are culled (not rendered).
    </p>
    <FrustumVisualizer client:visible />
    
    <h3 class="text-xl font-semibold text-white mt-12 mb-4">Dolly Zoom (Vertigo Effect)</h3>
    <p class="text-text-secondary mb-4">
      The famous "Hitchcock zoom" — moving the camera while changing FOV to keep the subject
      the same size while the background dramatically warps.
    </p>
    <DollyZoom client:visible />
  </section>

  <!-- Quiz -->
  <section class="mb-16">
    <h2 class="text-2xl font-bold text-accent mb-4 flex items-center gap-2">
      <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z"/></svg>
      Knowledge Check
    </h2>
    
    <p class="text-text-secondary mb-6">
      Test your understanding of camera systems!
    </p>

    <Quiz 
      client:visible
      title="Camera Systems Quiz"
      questions={quizQuestions}
    />
  </section>

  <!-- Mark Complete -->
  <section class="mb-16 py-8 border-y border-border">
    <MarkComplete 
      client:load 
      moduleId="17-cameras" 
      moduleName="Camera Systems"
    />
  </section>

  <!-- What's Next -->
  <section class="mb-8">
    <h2 class="text-2xl font-bold text-accent mb-4 flex items-center gap-2">
      <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 17 5-5-5-5"/><path d="m13 17 5-5-5-5"/></svg>
      What's Next
    </h2>
    
    <p class="text-text-secondary mb-4">
      You've mastered camera systems! Here are some advanced topics to explore:
    </p>
    
    <ol class="list-decimal list-inside space-y-3 text-text-secondary">
      <li>
        <strong class="text-white">Camera Collision:</strong> Prevent cameras from clipping through walls
      </li>
      <li>
        <strong class="text-white">Camera Shake:</strong> Add impact feedback for explosions and hits
      </li>
      <li>
        <strong class="text-white">Multi-Camera Systems:</strong> Picture-in-picture, split-screen multiplayer
      </li>
      <li>
        <strong class="text-white">VR Cameras:</strong> Stereoscopic rendering and head tracking
      </li>
    </ol>

    <div class="mt-8 p-6 bg-gradient-to-r from-[#6c5ce7]/20 to-[#00b894]/20 border border-[#6c5ce7] rounded-xl">
      <div class="flex items-center gap-3 mb-3">
        <svg class="w-6 h-6 text-[#00b894]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg>
        <span class="text-[#00b894] font-bold">Great Progress!</span>
      </div>
      <p class="text-text-secondary">
        Cameras are fundamental to player experience. Whether you're building an FPS, a strategy game,
        or a cinematic adventure, the skills you've learned here will help you create the perfect
        window into your game world!
      </p>
    </div>
  </section>
</ModuleLayout>
