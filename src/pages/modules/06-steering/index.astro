---
import ModuleLayout from '../../../layouts/ModuleLayout.astro';
import FlockingSimulation, { SeekDemo, FleeDemo, ArriveDemo, WanderDemo, ForceVisualization } from '../../../components/modules/FlockingSimulation';
import Quiz from '../../../components/lessons/Quiz';

// Code snippets
const codeSteeringBasics = `// Steering Force = Desired Velocity - Current Velocity
function steer(agent, target, maxSpeed, maxForce) {
    // Calculate desired velocity (toward target)
    const desired = {
        x: target.x - agent.x,
        y: target.y - agent.y
    };
    
    // Normalize and scale to max speed
    const mag = Math.sqrt(desired.x**2 + desired.y**2);
    desired.x = (desired.x / mag) * maxSpeed;
    desired.y = (desired.y / mag) * maxSpeed;
    
    // Steering = desired - current
    const steering = {
        x: desired.x - agent.vx,
        y: desired.y - agent.vy
    };
    
    // Limit steering force
    return limit(steering, maxForce);
}`;

const codeSeek = `// SEEK: Move toward a target
function seek(agent, target, maxSpeed, maxForce) {
    const desired = subtract(target, agent.position);
    const desiredVel = setMagnitude(desired, maxSpeed);
    const steer = subtract(desiredVel, agent.velocity);
    return limit(steer, maxForce);
}

// Each frame:
const seekForce = seek(agent, target, MAX_SPEED, MAX_FORCE);
agent.acceleration = seekForce;
agent.velocity = add(agent.velocity, agent.acceleration);
agent.position = add(agent.position, agent.velocity);`;

const codeFlee = `// FLEE: Move away from a threat
function flee(agent, threat, maxSpeed, maxForce, fleeRadius) {
    const d = distance(agent.position, threat);
    
    // Only flee if within danger zone
    if (d > fleeRadius) return { x: 0, y: 0 };
    
    // Desired velocity points AWAY from threat
    const desired = subtract(agent.position, threat);
    const desiredVel = setMagnitude(desired, maxSpeed);
    const steer = subtract(desiredVel, agent.velocity);
    
    // Strength diminishes with distance
    const strength = 1 - (d / fleeRadius);
    return scale(limit(steer, maxForce), strength);
}`;

const codeArrive = `// ARRIVE: Seek with gradual slowdown
function arrive(agent, target, maxSpeed, maxForce, slowRadius) {
    const desired = subtract(target, agent.position);
    const d = magnitude(desired);
    
    // Calculate speed based on distance
    let speed = maxSpeed;
    if (d < slowRadius) {
        // Slow down proportionally within radius
        speed = maxSpeed * (d / slowRadius);
    }
    
    const desiredVel = setMagnitude(desired, speed);
    const steer = subtract(desiredVel, agent.velocity);
    return limit(steer, maxForce);
}`;

const codeWander = `// WANDER: Random exploration using a circle
function wander(agent, wanderAngle) {
    const WANDER_RADIUS = 50;   // Size of wander circle
    const WANDER_DIST = 80;     // Distance ahead of agent
    const ANGLE_CHANGE = 0.5;   // Max random turn per frame
    
    // Get circle center ahead of agent
    const velocity = normalize(agent.velocity);
    const circleCenter = add(
        agent.position, 
        scale(velocity, WANDER_DIST)
    );
    
    // Random point on the circle
    wanderAngle += random(-ANGLE_CHANGE, ANGLE_CHANGE);
    const displacement = {
        x: Math.cos(wanderAngle) * WANDER_RADIUS,
        y: Math.sin(wanderAngle) * WANDER_RADIUS
    };
    
    // Seek that point
    const wanderTarget = add(circleCenter, displacement);
    return seek(agent, wanderTarget);
}`;

const codeObstacleAvoidance = `// OBSTACLE AVOIDANCE
function avoidObstacles(agent, obstacles, maxSpeed, maxForce) {
    let steering = { x: 0, y: 0 };
    
    for (const obstacle of obstacles) {
        const d = distance(agent.position, obstacle.position);
        const avoidDist = obstacle.radius + SAFE_MARGIN;
        
        if (d < avoidDist) {
            // Vector pointing away from obstacle
            const diff = subtract(agent.position, obstacle.position);
            
            // Weight by inverse distance (closer = stronger)
            const weighted = scale(normalize(diff), 1 / d);
            steering = add(steering, weighted);
        }
    }
    
    // Apply as strong steering force
    return scale(limit(steering, maxForce), 2);
}`;

const codeSeparation = `// SEPARATION: Avoid crowding neighbors
function separation(boid, flock, perceptionRadius) {
    let steering = { x: 0, y: 0 };
    let count = 0;
    
    for (const other of flock) {
        if (other === boid) continue;
        
        const d = distance(boid.position, other.position);
        if (d < perceptionRadius) {
            // Vector pointing away from neighbor
            const diff = subtract(boid.position, other.position);
            // Weighted by distance (closer = stronger push)
            const weighted = scale(normalize(diff), 1 / d);
            steering = add(steering, weighted);
            count++;
        }
    }
    
    if (count > 0) {
        steering = scale(steering, 1 / count);  // Average
        steering = setMagnitude(steering, maxSpeed);
        steering = subtract(steering, boid.velocity);
    }
    return limit(steering, maxForce);
}`;

const codeAlignment = `// ALIGNMENT: Match average heading of neighbors
function alignment(boid, flock, perceptionRadius) {
    let avgVelocity = { x: 0, y: 0 };
    let count = 0;
    
    for (const other of flock) {
        if (other === boid) continue;
        
        const d = distance(boid.position, other.position);
        if (d < perceptionRadius) {
            avgVelocity = add(avgVelocity, other.velocity);
            count++;
        }
    }
    
    if (count > 0) {
        avgVelocity = scale(avgVelocity, 1 / count);
        avgVelocity = setMagnitude(avgVelocity, maxSpeed);
        const steer = subtract(avgVelocity, boid.velocity);
        return limit(steer, maxForce);
    }
    return { x: 0, y: 0 };
}`;

const codeCohesion = `// COHESION: Move toward center of neighbors
function cohesion(boid, flock, perceptionRadius) {
    let centerOfMass = { x: 0, y: 0 };
    let count = 0;
    
    for (const other of flock) {
        if (other === boid) continue;
        
        const d = distance(boid.position, other.position);
        if (d < perceptionRadius) {
            centerOfMass = add(centerOfMass, other.position);
            count++;
        }
    }
    
    if (count > 0) {
        centerOfMass = scale(centerOfMass, 1 / count);
        // Seek the center
        return seek(boid, centerOfMass, maxSpeed, maxForce);
    }
    return { x: 0, y: 0 };
}`;

const codeCombined = `// COMBINING BEHAVIORS with weighted blending
function flock(boid, allBoids) {
    // Calculate individual forces
    const sep = separation(boid, allBoids, PERCEPTION_RADIUS);
    const ali = alignment(boid, allBoids, PERCEPTION_RADIUS);
    const coh = cohesion(boid, allBoids, PERCEPTION_RADIUS);
    
    // Apply weights (tune these for different behaviors!)
    const sepWeight = 1.5;  // Avoid collisions (important!)
    const aliWeight = 1.0;  // Match neighbors
    const cohWeight = 1.0;  // Stay together
    
    // Combine weighted forces
    boid.acceleration = add(
        scale(sep, sepWeight),
        add(
            scale(ali, aliWeight),
            scale(coh, cohWeight)
        )
    );
    
    // Update physics
    boid.velocity = add(boid.velocity, boid.acceleration);
    boid.velocity = limit(boid.velocity, MAX_SPEED);
    boid.position = add(boid.position, boid.velocity);
}`;

// Quiz questions
const quizQuestions = [
  {
    type: 'multiple-choice' as const,
    question: 'What is the formula for calculating a steering force?',
    options: [
      'Steering = Position - Target',
      'Steering = Desired Velocity - Current Velocity',
      'Steering = Acceleration × Time',
      'Steering = Force ÷ Mass'
    ],
    correctIndex: 1,
    explanation: 'Steering Force = Desired Velocity - Current Velocity. We calculate where we WANT to go (desired), then subtract where we ARE going (current) to get the correction needed.'
  },
  {
    type: 'multiple-choice' as const,
    question: 'What is the key difference between SEEK and ARRIVE behaviors?',
    options: [
      'Seek is faster than Arrive',
      'Arrive slows down when approaching the target',
      'Seek moves away from targets',
      'Arrive uses random movement'
    ],
    correctIndex: 1,
    explanation: 'ARRIVE includes a "slowing radius" - when the agent enters this radius, it gradually reduces speed proportional to distance, allowing smooth stops at the target. SEEK maintains full speed even near the target.'
  },
  {
    type: 'multiple-choice' as const,
    question: 'In flocking simulation, what does SEPARATION do?',
    options: [
      'Makes boids move toward the center of the flock',
      'Makes boids match the heading of neighbors',
      'Makes boids avoid crowding their neighbors',
      'Makes boids follow a leader'
    ],
    correctIndex: 2,
    explanation: 'SEPARATION prevents boids from getting too close to each other. Each boid steers away from nearby neighbors, with closer neighbors causing stronger repulsion. This prevents collisions and overcrowding.'
  },
  {
    type: 'code-completion' as const,
    question: 'Complete the code to calculate the steering force for SEEK:',
    codeTemplate: 'const desired = subtract(target, agent.position);\nconst steer = subtract(desired, agent.___);\nreturn limit(steer, maxForce);',
    answers: ['velocity'],
    explanation: 'Steering = Desired - Current Velocity. We subtract the agent\'s current velocity from the desired velocity to get the force needed to correct course.'
  },
  {
    type: 'multiple-choice' as const,
    question: 'What does ALIGNMENT do in flocking behavior?',
    options: [
      'Steers boids toward the center of mass',
      'Steers boids to match the average heading of neighbors',
      'Steers boids away from predators',
      'Steers boids around obstacles'
    ],
    correctIndex: 1,
    explanation: 'ALIGNMENT calculates the average velocity (direction + speed) of nearby neighbors and steers the boid to match it. This creates coordinated movement where the flock moves in the same direction.'
  },
  {
    type: 'multiple-choice' as const,
    question: 'Why is the separation weight typically higher than other flocking weights?',
    options: [
      'To make boids move faster',
      'To prevent collisions (safety is priority)',
      'To create more random movement',
      'To make the flock spread out more'
    ],
    correctIndex: 1,
    explanation: 'Separation weight is usually 1.5× or higher because avoiding collisions is critical. If boids collide, the simulation looks broken. Other behaviors are less urgent - it\'s okay to be slightly misaligned, but not okay to crash!'
  },
  {
    type: 'code-completion' as const,
    question: 'Complete the FLEE behavior - boids should flee when within the danger radius:',
    codeTemplate: 'const d = distance(agent.position, threat);\nif (d > fleeRadius) return { x: 0, y: 0 };\nconst desired = ___(agent.position, threat);',
    answers: ['subtract'],
    explanation: 'FLEE is the opposite of SEEK. We subtract THREAT from POSITION (not position from threat) to get a vector pointing AWAY from the threat. The agent then steers in that direction.'
  },
  {
    type: 'multiple-choice' as const,
    question: 'What technique does WANDER use to create natural-looking random movement?',
    options: [
      'Complete random direction each frame',
      'A wander circle projected ahead of the agent',
      'Following a predetermined path',
      'Bouncing off walls randomly'
    ],
    correctIndex: 1,
    explanation: 'WANDER projects a circle in front of the agent and picks a random point on it to seek. The point only changes slightly each frame, creating smooth, organic-looking exploration rather than jittery random movement.'
  }
];
---

<ModuleLayout 
  title="Steering Behaviors"
  moduleNumber="06"
  projectName="Flocking Simulation"
  prevModule={{ href: '/modules/05-state-machines/', title: 'State Machines' }}
  nextModule={{ href: '/modules/07-pathfinding/', title: 'Pathfinding' }}
>
  <!-- Lesson 1: Introduction to Steering Behaviors -->
  <section class="mb-16">
    <h2 class="text-2xl font-bold text-accent mb-4">1. Autonomous Agents</h2>
    
    <p class="text-text-secondary mb-4">
      <strong class="text-white">Steering behaviors</strong> are techniques for creating intelligent-looking movement 
      in game characters. Instead of scripting exact paths, we define <em>goals</em> and let agents figure out how to achieve them.
    </p>
    
    <p class="text-text-secondary mb-4">
      An <strong class="text-white">autonomous agent</strong> has three key properties:
    </p>
    
    <ul class="list-none space-y-3 mb-6 text-text-secondary">
      <li class="flex items-start gap-2">
        <svg class="w-5 h-5 text-accent flex-shrink-0 mt-0.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>
        <span><strong class="text-white">Perception</strong> — Can sense its environment (position, nearby objects)</span>
      </li>
      <li class="flex items-start gap-2">
        <svg class="w-5 h-5 text-accent flex-shrink-0 mt-0.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.12 2.12 0 0 1 3 3L7 19l-4 1 1-4Z"/></svg>
        <span><strong class="text-white">Decision-making</strong> — Can choose actions based on goals</span>
      </li>
      <li class="flex items-start gap-2">
        <svg class="w-5 h-5 text-accent flex-shrink-0 mt-0.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>
        <span><strong class="text-white">Action</strong> — Can affect the world (movement, rotation)</span>
      </li>
    </ul>

    <p class="text-text-secondary mb-4">
      The core formula for all steering behaviors is beautifully simple:
    </p>

    <div class="bg-[#6c5ce7]/10 border border-[#6c5ce7]/30 rounded-xl p-6 mb-6 text-center">
      <code class="text-lg text-[#6c5ce7] font-bold">Steering = Desired Velocity − Current Velocity</code>
    </div>

    <p class="text-text-secondary mb-6">
      We calculate where we <em>want</em> to go (desired), subtract where we <em>are</em> going (current), 
      and apply the difference as a force. This naturally corrects our course!
    </p>

    <div class="bg-bg-card rounded-xl p-6 mb-6">
      <pre class="text-sm overflow-x-auto"><code set:text={codeSteeringBasics} /></pre>
    </div>

    <div class="bg-[#00b894]/10 border border-[#00b894]/30 rounded-xl p-4">
      <p class="text-sm text-text-secondary flex items-start gap-2">
        <svg class="w-5 h-5 text-[#00b894] flex-shrink-0 mt-0.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5"/><path d="M9 18h6"/><path d="M10 22h4"/></svg>
        <span><strong class="text-[#00b894]">Key Insight:</strong> Unlike physics forces (gravity, collisions), 
        steering forces represent <em>intent</em>. The agent "wants" to go somewhere and adjusts its velocity accordingly.</span>
      </p>
    </div>
  </section>

  <!-- Lesson 2: Seek and Flee -->
  <section class="mb-16">
    <h2 class="text-2xl font-bold text-accent mb-4">2. Seek and Flee</h2>
    
    <p class="text-text-secondary mb-4">
      <strong class="text-white">SEEK</strong> is the most fundamental steering behavior: move toward a target.
    </p>

    <div class="bg-bg-card rounded-xl p-6 mb-6">
      <pre class="text-sm overflow-x-auto"><code set:text={codeSeek} /></pre>
    </div>

    <p class="text-text-secondary mb-4">
      Try it! Click anywhere to set the target position:
    </p>

    <SeekDemo client:visible />

    <p class="text-text-secondary mb-4 mt-8">
      <strong class="text-white">FLEE</strong> is the exact opposite: move away from a threat.
    </p>

    <div class="bg-bg-card rounded-xl p-6 mb-6">
      <pre class="text-sm overflow-x-auto"><code set:text={codeFlee} /></pre>
    </div>

    <p class="text-text-secondary mb-4">
      Move your mouse to control the predator. The agent will flee when you get too close:
    </p>

    <FleeDemo client:visible />

    <div class="bg-[#fdcb6e]/10 border border-[#fdcb6e]/30 rounded-xl p-4 mt-6">
      <p class="text-sm text-text-secondary flex items-start gap-2">
        <svg class="w-5 h-5 text-[#fdcb6e] flex-shrink-0 mt-0.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg>
        <span><strong class="text-[#fdcb6e]">Notice:</strong> The flee force gets stronger as the predator gets closer, 
        and fades to zero at the edge of the "flee radius". This creates realistic panic-like behavior!</span>
      </p>
    </div>
  </section>

  <!-- Lesson 3: Arrive -->
  <section class="mb-16">
    <h2 class="text-2xl font-bold text-accent mb-4">3. Arrive: Smooth Stops</h2>
    
    <p class="text-text-secondary mb-4">
      Basic SEEK has a problem: the agent overshoots the target and oscillates around it. 
      <strong class="text-white">ARRIVE</strong> solves this by gradually slowing down when approaching.
    </p>

    <div class="bg-bg-card rounded-xl p-6 mb-6">
      <pre class="text-sm overflow-x-auto"><code set:text={codeArrive} /></pre>
    </div>

    <p class="text-text-secondary mb-4">
      Watch how the agent decelerates smoothly within the blue "slow radius":
    </p>

    <ArriveDemo client:visible />

    <div class="bg-[#74b9ff]/10 border border-[#74b9ff]/30 rounded-xl p-4 mt-6">
      <p class="text-sm text-text-secondary flex items-start gap-2">
        <svg class="w-5 h-5 text-[#74b9ff] flex-shrink-0 mt-0.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="6" x2="10" y1="11" y2="11"/><line x1="8" x2="8" y1="9" y2="13"/><line x1="15" x2="15.01" y1="12" y2="12"/><line x1="18" x2="18.01" y1="10" y2="10"/><path d="M17.32 5H6.68a4 4 0 0 0-3.978 3.59c-.006.052-.01.101-.017.152C2.604 9.416 2 14.456 2 16a3 3 0 0 0 3 3c1 0 1.5-.5 2-1l1.414-1.414A2 2 0 0 1 9.828 16h4.344a2 2 0 0 1 1.414.586L17 18c.5.5 1 1 2 1a3 3 0 0 0 3-3c0-1.545-.604-6.584-.685-7.258-.007-.05-.011-.1-.017-.151A4 4 0 0 0 17.32 5z"/></svg>
        <span><strong class="text-[#74b9ff]">Game Design Tip:</strong> ARRIVE is essential for click-to-move games, 
        NPC walking to waypoints, and any situation where you need precise positioning without jittery stops.</span>
      </p>
    </div>
  </section>

  <!-- Lesson 4: Wander -->
  <section class="mb-16">
    <h2 class="text-2xl font-bold text-accent mb-4">4. Wander: Random Exploration</h2>
    
    <p class="text-text-secondary mb-4">
      Simply picking a random direction each frame creates jittery, unnatural movement. 
      <strong class="text-white">WANDER</strong> uses a clever trick: project a circle ahead of the agent 
      and pick a target point on it that changes gradually.
    </p>

    <div class="bg-bg-card rounded-xl p-6 mb-6">
      <pre class="text-sm overflow-x-auto"><code set:text={codeWander} /></pre>
    </div>

    <p class="text-text-secondary mb-4">
      Watch the wander circle (yellow) - the target point moves smoothly around it:
    </p>

    <WanderDemo client:visible />

    <div class="bg-[#6c5ce7]/10 border border-[#6c5ce7]/30 rounded-xl p-4 mt-6">
      <p class="text-sm text-text-secondary flex items-start gap-2">
        <svg class="w-5 h-5 text-[#6c5ce7] flex-shrink-0 mt-0.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg>
        <span><strong class="text-[#6c5ce7]">Parameters to tune:</strong> <code>WANDER_RADIUS</code> (larger = wider turns), 
        <code>WANDER_DIST</code> (larger = smoother curves), <code>ANGLE_CHANGE</code> (larger = more erratic).</span>
      </p>
    </div>
  </section>

  <!-- Lesson 5: Obstacle Avoidance -->
  <section class="mb-16">
    <h2 class="text-2xl font-bold text-accent mb-4">5. Obstacle Avoidance</h2>
    
    <p class="text-text-secondary mb-4">
      Agents need to navigate around walls and obstacles without explicit pathfinding. 
      <strong class="text-white">Obstacle avoidance</strong> detects nearby obstacles and steers away.
    </p>

    <div class="bg-bg-card rounded-xl p-6 mb-6">
      <pre class="text-sm overflow-x-auto"><code set:text={codeObstacleAvoidance} /></pre>
    </div>

    <ul class="list-none space-y-2 mb-6 text-text-secondary">
      <li class="flex items-center gap-2">
        <svg class="w-4 h-4 text-[#00b894]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg>
        <span>Agents "see" obstacles within a detection radius</span>
      </li>
      <li class="flex items-center gap-2">
        <svg class="w-4 h-4 text-[#00b894]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg>
        <span>Closer obstacles create stronger repulsion</span>
      </li>
      <li class="flex items-center gap-2">
        <svg class="w-4 h-4 text-[#00b894]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg>
        <span>Multiple obstacles combine their forces</span>
      </li>
      <li class="flex items-center gap-2">
        <svg class="w-4 h-4 text-[#00b894]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg>
        <span>Avoidance force is typically weighted higher than other behaviors</span>
      </li>
    </ul>

    <div class="bg-[#e17055]/10 border border-[#e17055]/30 rounded-xl p-4">
      <p class="text-sm text-text-secondary flex items-start gap-2">
        <svg class="w-5 h-5 text-[#e17055] flex-shrink-0 mt-0.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="15" x2="9" y1="9" y2="15"/><line x1="9" x2="15" y1="9" y2="15"/></svg>
        <span><strong class="text-[#e17055]">Limitation:</strong> Simple obstacle avoidance can get stuck in corners or 
        local minima. For complex environments, combine with pathfinding (next module!).</span>
      </p>
    </div>
  </section>

  <!-- Lesson 6: Flocking Rules -->
  <section class="mb-16">
    <h2 class="text-2xl font-bold text-accent mb-4">6. Flocking: The Three Rules</h2>
    
    <p class="text-text-secondary mb-4">
      In 1986, Craig Reynolds created "Boids" - a simulation that produces realistic flocking behavior 
      using just <strong class="text-white">three simple rules</strong>:
    </p>

    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
      <div class="bg-bg-card rounded-xl p-4 border-l-4 border-[#e17055]">
        <h3 class="font-bold text-white mb-2 flex items-center gap-2">
          <svg class="w-5 h-5 text-[#e17055]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m18 15-6-6-6 6"/></svg>
          Separation
        </h3>
        <p class="text-sm text-text-secondary">Steer to avoid crowding neighbors. Don't get too close!</p>
      </div>
      <div class="bg-bg-card rounded-xl p-4 border-l-4 border-[#00b894]">
        <h3 class="font-bold text-white mb-2 flex items-center gap-2">
          <svg class="w-5 h-5 text-[#00b894]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>
          Alignment
        </h3>
        <p class="text-sm text-text-secondary">Steer toward average heading of neighbors. Go the same way!</p>
      </div>
      <div class="bg-bg-card rounded-xl p-4 border-l-4 border-[#74b9ff]">
        <h3 class="font-bold text-white mb-2 flex items-center gap-2">
          <svg class="w-5 h-5 text-[#74b9ff]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><circle cx="12" cy="12" r="10"/></svg>
          Cohesion
        </h3>
        <p class="text-sm text-text-secondary">Steer toward center of mass of neighbors. Stay together!</p>
      </div>
    </div>

    <h3 class="text-xl font-bold text-white mb-3">Separation</h3>
    <div class="bg-bg-card rounded-xl p-6 mb-6">
      <pre class="text-sm overflow-x-auto"><code set:text={codeSeparation} /></pre>
    </div>

    <h3 class="text-xl font-bold text-white mb-3">Alignment</h3>
    <div class="bg-bg-card rounded-xl p-6 mb-6">
      <pre class="text-sm overflow-x-auto"><code set:text={codeAlignment} /></pre>
    </div>

    <h3 class="text-xl font-bold text-white mb-3">Cohesion</h3>
    <div class="bg-bg-card rounded-xl p-6 mb-6">
      <pre class="text-sm overflow-x-auto"><code set:text={codeCohesion} /></pre>
    </div>

    <p class="text-text-secondary mb-4">
      See how these three forces interact in real-time:
    </p>

    <ForceVisualization client:visible />
  </section>

  <!-- Lesson 7: Combining Behaviors -->
  <section class="mb-16">
    <h2 class="text-2xl font-bold text-accent mb-4">7. Combining Behaviors</h2>
    
    <p class="text-text-secondary mb-4">
      The magic happens when we <strong class="text-white">combine multiple steering behaviors</strong> 
      using weighted blending. Each behavior contributes a force, and we sum them up.
    </p>

    <div class="bg-bg-card rounded-xl p-6 mb-6">
      <pre class="text-sm overflow-x-auto"><code set:text={codeCombined} /></pre>
    </div>

    <div class="bg-[#6c5ce7]/10 border border-[#6c5ce7]/30 rounded-xl p-4 mb-6">
      <p class="text-sm text-text-secondary flex items-start gap-2">
        <svg class="w-5 h-5 text-[#6c5ce7] flex-shrink-0 mt-0.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>
        <span><strong class="text-[#6c5ce7]">Emergent Behavior:</strong> Complex, lifelike movement emerges from 
        simple rules! No individual boid knows about the "flock" - each just follows its local rules.</span>
      </p>
    </div>

    <h3 class="text-xl font-bold text-white mb-3">Weight Guidelines</h3>
    <ul class="list-none space-y-2 mb-6 text-text-secondary">
      <li class="flex items-start gap-2">
        <span class="w-3 h-3 rounded-full bg-[#e17055] flex-shrink-0 mt-1.5" />
        <span><strong class="text-white">Separation (1.5×)</strong> — Highest priority. Collisions break immersion.</span>
      </li>
      <li class="flex items-start gap-2">
        <span class="w-3 h-3 rounded-full bg-[#00b894] flex-shrink-0 mt-1.5" />
        <span><strong class="text-white">Alignment (1.0×)</strong> — Creates that satisfying synchronized movement.</span>
      </li>
      <li class="flex items-start gap-2">
        <span class="w-3 h-3 rounded-full bg-[#74b9ff] flex-shrink-0 mt-1.5" />
        <span><strong class="text-white">Cohesion (1.0×)</strong> — Keeps the flock together without being clingy.</span>
      </li>
    </ul>
  </section>

  <!-- Project: Flocking Simulation -->
  <section class="mb-16">
    <h2 class="text-2xl font-bold text-accent mb-4 flex items-center gap-2">
      <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="6" x2="10" y1="11" y2="11"/><line x1="8" x2="8" y1="9" y2="13"/><line x1="15" x2="15.01" y1="12" y2="12"/><line x1="18" x2="18.01" y1="10" y2="10"/><path d="M17.32 5H6.68a4 4 0 0 0-3.978 3.59c-.006.052-.01.101-.017.152C2.604 9.416 2 14.456 2 16a3 3 0 0 0 3 3c1 0 1.5-.5 2-1l1.414-1.414A2 2 0 0 1 9.828 16h4.344a2 2 0 0 1 1.414.586L17 18c.5.5 1 1 2 1a3 3 0 0 0 3-3c0-1.545-.604-6.584-.685-7.258-.007-.05-.011-.1-.017-.151A4 4 0 0 0 17.32 5z"/></svg>
      Project: Flocking Simulation
    </h2>
    
    <p class="text-text-secondary mb-6">
      Experience all the concepts in action! Adjust the sliders to see how different weights affect behavior:
    </p>

    <ul class="list-none space-y-2 mb-8 text-text-secondary">
      <li class="flex items-center gap-2">
        <svg class="w-4 h-4 text-[#00b894]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg>
        <span><strong class="text-white">Boid count slider</strong> — See how 10 vs 200 boids behave</span>
      </li>
      <li class="flex items-center gap-2">
        <svg class="w-4 h-4 text-[#00b894]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg>
        <span><strong class="text-white">Behavior weights</strong> — Tune separation, alignment, cohesion</span>
      </li>
      <li class="flex items-center gap-2">
        <svg class="w-4 h-4 text-[#00b894]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg>
        <span><strong class="text-white">Predator mode</strong> — Move mouse to scare the flock</span>
      </li>
      <li class="flex items-center gap-2">
        <svg class="w-4 h-4 text-[#00b894]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg>
        <span><strong class="text-white">Debug mode</strong> — View perception radius and velocity vectors</span>
      </li>
      <li class="flex items-center gap-2">
        <svg class="w-4 h-4 text-[#00b894]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg>
        <span><strong class="text-white">Force visualization</strong> — See individual steering forces as colored arrows</span>
      </li>
    </ul>

    <FlockingSimulation client:visible />
  </section>

  <!-- Challenges -->
  <section class="mb-8">
    <h2 class="text-2xl font-bold text-accent mb-4 flex items-center gap-2">
      <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m14.5 12.5-5 5"/><path d="m9.5 12.5 5 5"/><path d="M6 10h4"/><path d="M8 8v4"/><path d="M17.32 5H6.68a4 4 0 0 0-3.978 3.59c-.006.052-.01.101-.017.152C2.604 9.416 2 14.456 2 16a3 3 0 0 0 3 3c1 0 1.5-.5 2-1l1.414-1.414A2 2 0 0 1 9.828 16h4.344a2 2 0 0 1 1.414.586L17 18c.5.5 1 1 2 1a3 3 0 0 0 3-3c0-1.545-.604-6.584-.685-7.258-.007-.05-.011-.1-.017-.151A4 4 0 0 0 17.32 5z"/></svg>
      Challenges
    </h2>
    
    <ol class="list-decimal list-inside space-y-3 text-text-secondary">
      <li>
        <strong class="text-white">Leader Following:</strong> Add a "leader" boid that others follow using SEEK
      </li>
      <li>
        <strong class="text-white">Multiple Flocks:</strong> Create different colored flocks that avoid each other
      </li>
      <li>
        <strong class="text-white">Food Sources:</strong> Add targets that attract boids, which "eat" and disappear
      </li>
      <li>
        <strong class="text-white">Pursuit & Evade:</strong> Implement a smarter predator that predicts prey movement
      </li>
      <li>
        <strong class="text-white">Flow Fields:</strong> Create a vector field that influences all boid movement
      </li>
    </ol>
  </section>

  <!-- Formula Reference -->
  <section class="mb-8">
    <h2 class="text-2xl font-bold text-accent mb-4 flex items-center gap-2">
      <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M7 12h10"/><path d="M10 18h4"/></svg>
      Quick Reference
    </h2>
    
    <div class="bg-bg-card rounded-xl p-6">
      <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div>
          <h3 class="font-bold text-white mb-2">Core Formula</h3>
          <ul class="text-sm text-text-secondary space-y-1">
            <li><code>Steering = Desired - Current</code></li>
            <li><code>Desired = normalize(target - position) × maxSpeed</code></li>
          </ul>
        </div>
        <div>
          <h3 class="font-bold text-white mb-2">Flocking Rules</h3>
          <ul class="text-sm text-text-secondary space-y-1">
            <li><code class="text-[#e17055]">Separation</code> — Avoid crowding</li>
            <li><code class="text-[#00b894]">Alignment</code> — Match heading</li>
            <li><code class="text-[#74b9ff]">Cohesion</code> — Seek center</li>
          </ul>
        </div>
        <div>
          <h3 class="font-bold text-white mb-2">Individual Behaviors</h3>
          <ul class="text-sm text-text-secondary space-y-1">
            <li><code>Seek</code> — Move toward target</li>
            <li><code>Flee</code> — Move away from threat</li>
            <li><code>Arrive</code> — Seek with slowdown</li>
            <li><code>Wander</code> — Random exploration</li>
          </ul>
        </div>
        <div>
          <h3 class="font-bold text-white mb-2">Typical Weights</h3>
          <ul class="text-sm text-text-secondary space-y-1">
            <li>Separation: <code>1.5</code></li>
            <li>Alignment: <code>1.0</code></li>
            <li>Cohesion: <code>1.0</code></li>
            <li>Obstacle: <code>2.0+</code></li>
          </ul>
        </div>
      </div>
    </div>
  </section>

  <!-- Quiz -->
  <section class="mb-8">
    <h2 class="text-2xl font-bold text-accent mb-4 flex items-center gap-2">
      <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>
      Knowledge Check
    </h2>
    <p class="text-text-secondary mb-6">
      Test your understanding of steering behaviors! Use number keys 1-4 to select answers.
    </p>
    <Quiz 
      client:visible 
      title="Steering Behaviors Quiz" 
      questions={quizQuestions} 
    />
  </section>
</ModuleLayout>
